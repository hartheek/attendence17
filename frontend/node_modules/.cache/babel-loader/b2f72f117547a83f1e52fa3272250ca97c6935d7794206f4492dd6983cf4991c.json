{"ast":null,"code":"'use strict';\n\nvar util = require('util');\nvar AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\nvar YandexGeocoder = function YandexGeocoder(httpAdapter, options) {\n  this.options = ['apiKey'];\n  YandexGeocoder.super_.call(this, httpAdapter, options);\n};\nutil.inherits(YandexGeocoder, AbstractGeocoder);\nfunction _findKey(result, wantedKey) {\n  var val = null;\n  Object.keys(result).every(function (key) {\n    if (key === wantedKey) {\n      val = result[key];\n      return false;\n    }\n    if (typeof result[key] === 'object') {\n      val = _findKey(result[key], wantedKey);\n      return val === null ? true : false;\n    }\n    return true;\n  });\n  return val;\n}\nfunction _formatResult(result) {\n  var position = result.GeoObject.Point.pos.split(' ');\n  result = result.GeoObject.metaDataProperty.GeocoderMetaData.AddressDetails;\n  return {\n    'latitude': parseFloat(position[1]),\n    'longitude': parseFloat(position[0]),\n    'city': _findKey(result, 'LocalityName'),\n    'state': _findKey(result, 'AdministrativeAreaName'),\n    'streetName': _findKey(result, 'ThoroughfareName'),\n    'streetNumber': _findKey(result, 'PremiseNumber'),\n    'countryCode': _findKey(result, 'CountryNameCode'),\n    'country': _findKey(result, 'CountryName'),\n    'formattedAddress': _findKey(result, 'AddressLine')\n  };\n}\nfunction _processOptionsToParams(params, options) {\n  //language (language_region, ex: `ru_RU`, `uk_UA`)\n  if (options.language) {\n    params.lang = options.language;\n  }\n\n  //results count (default 10)\n  if (options.results) {\n    params.results = options.results;\n  }\n\n  //skip count (default 0)\n  if (options.skip) {\n    params.skip = options.skip;\n  }\n\n  //Type of toponym (only for reverse geocoding)\n  //could be `house`, `street`, `metro`, `district`, `locality`\n  if (options.kind) {\n    params.kind = options.kind;\n  }\n\n  //BBox (ex: `[[lat: 1.0, lng:2.0],[lat: 1.1, lng:2.2]]`)\n  if (options.bbox) {\n    if (options.bbox.length === 2) {\n      params.bbox = options.bbox[0].lng + ',' + options.bbox[0].lat;\n      params.bbox = params.bbox + '~';\n      params.bbox = params.bbox + options.bbox[1].lng + ',' + options.bbox[1].lat;\n    }\n  }\n\n  //Limit search in bbox (1) or not limit (0)\n  if (options.rspn) {\n    params.rspn = options.rspn;\n  }\n  if (options.apiKey) {\n    params.apikey = options.apiKey;\n  }\n}\n\n// Yandex geocoding API endpoint\nYandexGeocoder.prototype._endpoint = 'https://geocode-maps.yandex.ru/1.x/';\n\n/**\n* Geocode\n* @param <string>   value    Value to geocode (Address)\n* @param <function> callback Callback method\n*/\nYandexGeocoder.prototype._geocode = function (value, callback) {\n  var params = {\n    geocode: value,\n    format: 'json'\n  };\n  _processOptionsToParams(params, this.options);\n  this.httpAdapter.get(this._endpoint, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n      result.response.GeoObjectCollection.featureMember.forEach(function (geopoint) {\n        results.push(_formatResult(geopoint));\n      });\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\n/**\n * Reverse geocoding\n * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n * @param <function> callback Callback method\n */\nYandexGeocoder.prototype._reverse = function (query, callback) {\n  var lat = query.lat;\n  var lng = query.lon;\n  var value = lng + ',' + lat;\n  this._geocode(value, callback);\n};\nmodule.exports = YandexGeocoder;","map":{"version":3,"names":["util","require","AbstractGeocoder","YandexGeocoder","httpAdapter","options","super_","call","inherits","_findKey","result","wantedKey","val","Object","keys","every","key","_formatResult","position","GeoObject","Point","pos","split","metaDataProperty","GeocoderMetaData","AddressDetails","parseFloat","_processOptionsToParams","params","language","lang","results","skip","kind","bbox","length","lng","lat","rspn","apiKey","apikey","prototype","_endpoint","_geocode","value","callback","geocode","format","get","err","response","GeoObjectCollection","featureMember","forEach","geopoint","push","raw","_reverse","query","lon","module","exports"],"sources":["/home/pratheek/Desktop/Attendance/frontend/node_modules/node-geocoder/lib/geocoder/yandexgeocoder.js"],"sourcesContent":["'use strict';\n\nvar util = require('util');\nvar AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\nvar YandexGeocoder = function YandexGeocoder(httpAdapter, options) {\n  this.options = ['apiKey'];\n  YandexGeocoder.super_.call(this, httpAdapter, options);\n};\n\nutil.inherits(YandexGeocoder, AbstractGeocoder);\n\nfunction _findKey(result, wantedKey) {\n  var val = null;\n  Object.keys(result).every(function(key) {\n\n  if (key === wantedKey) {\n    val = result[key];\n    return false;\n  }\n\n  if (typeof result[key] === 'object') {\n    val = _findKey(result[key], wantedKey);\n\n    return val === null ? true : false;\n  }\n\n  return true;\n  });\n\n  return val;\n}\n\nfunction _formatResult(result) {\n  var position = result.GeoObject.Point.pos.split(' ');\n  result = result.GeoObject.metaDataProperty.GeocoderMetaData.AddressDetails;\n\n  return {\n    'latitude' : parseFloat(position[1]),\n    'longitude' : parseFloat(position[0]),\n    'city' : _findKey(result, 'LocalityName'),\n    'state' : _findKey(result, 'AdministrativeAreaName'),\n    'streetName': _findKey(result, 'ThoroughfareName'),\n    'streetNumber' : _findKey(result, 'PremiseNumber'),\n    'countryCode' : _findKey(result, 'CountryNameCode'),\n    'country' : _findKey(result, 'CountryName'),\n    'formattedAddress' : _findKey(result, 'AddressLine')\n  };\n}\n\nfunction _processOptionsToParams(params, options){\n\n  //language (language_region, ex: `ru_RU`, `uk_UA`)\n  if (options.language) {\n    params.lang = options.language;\n  }\n\n  //results count (default 10)\n  if (options.results) {\n    params.results = options.results;\n  }\n\n  //skip count (default 0)\n  if (options.skip) {\n    params.skip = options.skip;\n  }\n\n  //Type of toponym (only for reverse geocoding)\n  //could be `house`, `street`, `metro`, `district`, `locality`\n  if (options.kind) {\n    params.kind = options.kind;\n  }\n\n  //BBox (ex: `[[lat: 1.0, lng:2.0],[lat: 1.1, lng:2.2]]`)\n  if (options.bbox) {\n    if (options.bbox.length === 2){\n      params.bbox = options.bbox[0].lng + ',' + options.bbox[0].lat;\n      params.bbox = params.bbox + '~';\n      params.bbox = params.bbox + options.bbox[1].lng + ',' + options.bbox[1].lat;\n    }\n  }\n\n  //Limit search in bbox (1) or not limit (0)\n  if (options.rspn) {\n    params.rspn = options.rspn;\n  }\n\n  if(options.apiKey) {\n    params.apikey = options.apiKey;\n  }\n}\n\n// Yandex geocoding API endpoint\nYandexGeocoder.prototype._endpoint = 'https://geocode-maps.yandex.ru/1.x/';\n\n/**\n* Geocode\n* @param <string>   value    Value to geocode (Address)\n* @param <function> callback Callback method\n*/\nYandexGeocoder.prototype._geocode = function(value, callback) {\n  var params = {\n    geocode : value,\n    format: 'json'\n  };\n\n  _processOptionsToParams(params, this.options);\n\n  this.httpAdapter.get(this._endpoint, params, function(err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n\n      result.response.GeoObjectCollection.featureMember.forEach(function(geopoint) {\n        results.push(_formatResult(geopoint));\n      });\n\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\n/**\n * Reverse geocoding\n * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n * @param <function> callback Callback method\n */\nYandexGeocoder.prototype._reverse = function (query, callback) {\n  var lat = query.lat;\n  var lng = query.lon;\n\n  var value = lng + ',' + lat;\n\n  this._geocode(value, callback);\n};\n\n\nmodule.exports = YandexGeocoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}