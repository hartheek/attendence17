{"ast":null,"code":"const AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * available options\n * @see https://docs.mapbox.com/api/search/geocoding/\n */\nconst OPTIONS = ['apiKey', 'language', 'country', 'autocomplete', 'bbox', 'fuzzyMatch', 'limit', 'proximity', 'routing'];\nconst OPTIONS_MAP = {\n  apiKey: 'access_token'\n};\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options Options (apiKey, language, country, autocomplete, bbox, fuzzyMatch, limit, proximity, routing)\n */\nclass MapBoxGeocoder extends AbstractGeocoder {\n  constructor(httpAdapter, options) {\n    super(httpAdapter, options);\n    this.options = options || {};\n    if (!this.options.apiKey) {\n      throw new Error('You must specify apiKey to use MapBox Geocoder');\n    }\n  }\n\n  /**\n   * Geocode\n   * @param <string>   value    Value to geocode (Address)\n   * @param <function> callback Callback method\n   */\n  _geocode(value, callback) {\n    let params = this._prepareQueryString({});\n    let searchtext = value;\n    if (value.address) {\n      params = this._prepareQueryString(value);\n      searchtext = value.address;\n    }\n    const endpoint = `${this._geocodeEndpoint}/${encodeURIComponent(searchtext)}.json`;\n    this.httpAdapter.get(endpoint, params, (err, result) => {\n      let results = [];\n      results.raw = result;\n      if (err) {\n        return callback(err, results);\n      } else {\n        const view = result.features;\n        if (!view) {\n          return callback(false, results);\n        }\n        results = view.map(this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n\n  /**\n   * Reverse geocoding\n   * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n   * @param <function> callback Callback method\n   */\n  _reverse(query, callback) {\n    const {\n      lat,\n      lon,\n      ...other\n    } = query;\n    const params = this._prepareQueryString(other);\n    const endpoint = `${this._geocodeEndpoint}/${encodeURIComponent(`${lon},${lat}`)}.json`;\n    this.httpAdapter.get(endpoint, params, (err, result) => {\n      let results = [];\n      results.raw = result;\n      if (err) {\n        return callback(err, results);\n      } else {\n        const view = result.features;\n        if (!view) {\n          return callback(false, results);\n        }\n        results = view.map(this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n  _formatResult(result) {\n    const context = (result.context || []).reduce((o, item) => {\n      // possible types: country, region, postcode, district, place, locality, neighborhood, address\n      const [type] = item.id.split('.');\n      if (type) {\n        o[type] = item.text;\n        if (type === 'country' && item.short_code) {\n          o.countryCode = item.short_code.toUpperCase();\n        }\n      }\n      return o;\n    }, {});\n    // get main type\n    const [type] = result.id.split('.');\n    if (type) {\n      context[type] = result.text;\n    }\n    const properties = result.properties || {};\n    const extractedObj = {\n      latitude: result.center[1],\n      longitude: result.center[0],\n      formattedAddress: result.place_name,\n      country: context.country,\n      countryCode: context.countryCode,\n      state: context.region,\n      district: context.district,\n      city: context.place,\n      zipcode: context.postcode,\n      neighbourhood: context.neighborhood || context.locality,\n      extra: {\n        id: result.id,\n        address: properties.address || context.address,\n        category: properties.category,\n        bbox: result.bbox\n      }\n    };\n    return extractedObj;\n  }\n  _prepareQueryString(params) {\n    OPTIONS.forEach(key => {\n      const val = this.options[key];\n      if (val) {\n        const _key = OPTIONS_MAP[key] || key;\n        params[_key] = val;\n      }\n    });\n    return params;\n  }\n}\nObject.defineProperties(MapBoxGeocoder.prototype, {\n  _geocodeEndpoint: {\n    get: function () {\n      return 'https://api.mapbox.com/geocoding/v5/mapbox.places';\n    }\n  }\n});\nmodule.exports = MapBoxGeocoder;","map":{"version":3,"names":["AbstractGeocoder","require","OPTIONS","OPTIONS_MAP","apiKey","MapBoxGeocoder","constructor","httpAdapter","options","Error","_geocode","value","callback","params","_prepareQueryString","searchtext","address","endpoint","_geocodeEndpoint","encodeURIComponent","get","err","result","results","raw","view","features","map","_formatResult","_reverse","query","lat","lon","other","context","reduce","o","item","type","id","split","text","short_code","countryCode","toUpperCase","properties","extractedObj","latitude","center","longitude","formattedAddress","place_name","country","state","region","district","city","place","zipcode","postcode","neighbourhood","neighborhood","locality","extra","category","bbox","forEach","key","val","_key","Object","defineProperties","prototype","module","exports"],"sources":["/home/pratheek/Desktop/Attendance/frontend/node_modules/node-geocoder/lib/geocoder/mapboxgeocoder.js"],"sourcesContent":["const AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * available options\n * @see https://docs.mapbox.com/api/search/geocoding/\n */\nconst OPTIONS = [\n  'apiKey',\n  'language',\n  'country',\n  'autocomplete',\n  'bbox',\n  'fuzzyMatch',\n  'limit',\n  'proximity',\n  'routing'\n];\n\nconst OPTIONS_MAP = {\n  apiKey: 'access_token'\n};\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options Options (apiKey, language, country, autocomplete, bbox, fuzzyMatch, limit, proximity, routing)\n */\nclass MapBoxGeocoder extends AbstractGeocoder {\n  constructor(httpAdapter, options) {\n    super(httpAdapter, options);\n    this.options = options || {};\n\n    if (!this.options.apiKey) {\n      throw new Error('You must specify apiKey to use MapBox Geocoder');\n    }\n  }\n\n  /**\n   * Geocode\n   * @param <string>   value    Value to geocode (Address)\n   * @param <function> callback Callback method\n   */\n  _geocode(value, callback) {\n    let params = this._prepareQueryString({});\n    let searchtext = value;\n\n    if (value.address) {\n      params = this._prepareQueryString(value);\n      searchtext = value.address;\n    }\n\n    const endpoint = `${this._geocodeEndpoint}/${encodeURIComponent(\n      searchtext\n    )}.json`;\n\n    this.httpAdapter.get(endpoint, params, (err, result) => {\n      let results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        const view = result.features;\n        if (!view) {\n          return callback(false, results);\n        }\n        results = view.map(this._formatResult);\n        results.raw = result;\n\n        callback(false, results);\n      }\n    });\n  }\n\n  /**\n   * Reverse geocoding\n   * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n   * @param <function> callback Callback method\n   */\n  _reverse(query, callback) {\n    const { lat, lon, ...other } = query;\n\n    const params = this._prepareQueryString(other);\n    const endpoint = `${this._geocodeEndpoint}/${encodeURIComponent(\n      `${lon},${lat}`\n    )}.json`;\n\n    this.httpAdapter.get(endpoint, params, (err, result) => {\n      let results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        const view = result.features;\n        if (!view) {\n          return callback(false, results);\n        }\n        results = view.map(this._formatResult);\n        results.raw = result;\n\n        callback(false, results);\n      }\n    });\n  }\n\n  _formatResult(result) {\n    const context = (result.context || []).reduce((o, item) => {\n      // possible types: country, region, postcode, district, place, locality, neighborhood, address\n      const [type] = item.id.split('.');\n      if (type) {\n        o[type] = item.text;\n        if (type === 'country' && item.short_code) {\n          o.countryCode = item.short_code.toUpperCase();\n        }\n      }\n      return o;\n    }, {});\n    // get main type\n    const [type] = result.id.split('.');\n    if (type) {\n      context[type] = result.text;\n    }\n\n    const properties = result.properties || {};\n\n    const extractedObj = {\n      latitude: result.center[1],\n      longitude: result.center[0],\n      formattedAddress: result.place_name,\n      country: context.country,\n      countryCode: context.countryCode,\n      state: context.region,\n      district: context.district,\n      city: context.place,\n      zipcode: context.postcode,\n      neighbourhood: context.neighborhood || context.locality,\n      extra: {\n        id: result.id,\n        address: properties.address || context.address,\n        category: properties.category,\n        bbox: result.bbox\n      }\n    };\n\n    return extractedObj;\n  }\n\n  _prepareQueryString(params) {\n    OPTIONS.forEach(key => {\n      const val = this.options[key];\n      if (val) {\n        const _key = OPTIONS_MAP[key] || key;\n        params[_key] = val;\n      }\n    });\n\n    return params;\n  }\n}\n\nObject.defineProperties(MapBoxGeocoder.prototype, {\n  _geocodeEndpoint: {\n    get: function () {\n      return 'https://api.mapbox.com/geocoding/v5/mapbox.places';\n    }\n  }\n});\n\nmodule.exports = MapBoxGeocoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}