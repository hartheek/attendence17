{"ast":null,"code":"var util = require('util');\nvar AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\nvar TomTomGeocoder = function TomTomGeocoder(httpAdapter, options) {\n  TomTomGeocoder.super_.call(this, httpAdapter, options);\n  if (!this.options.apiKey || this.options.apiKey == 'undefined') {\n    throw new Error('You must specify an apiKey');\n  }\n};\nutil.inherits(TomTomGeocoder, AbstractGeocoder);\n\n// TomTom geocoding API endpoint\nTomTomGeocoder.prototype._endpoint = 'https://api.tomtom.com/search/2/geocode';\nTomTomGeocoder.prototype._batchGeocodingEndpoint = 'https://api.tomtom.com/search/2/batch.json';\n\n/**\n * Geocode\n * @param <string>   value    Value to geocode (Address)\n * @param <function> callback Callback method\n */\nTomTomGeocoder.prototype._geocode = function (value, callback) {\n  var _this = this;\n  var params = {\n    key: this.options.apiKey\n  };\n  if (this.options.language) {\n    params.language = this.options.language;\n  }\n  if (this.options.country) {\n    params.countrySet = this.options.country;\n  }\n  if (this.options.limit) {\n    params.limit = this.options.limit;\n  }\n  var url = this._endpoint + '/' + encodeURIComponent(value) + '.json';\n  this.httpAdapter.get(url, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n      for (var i = 0; i < result.results.length; i++) {\n        results.push(_this._formatResult(result.results[i]));\n      }\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\nTomTomGeocoder.prototype._formatResult = function (result) {\n  return {\n    latitude: result.position.lat,\n    longitude: result.position.lon,\n    country: result.address.country,\n    city: result.address.localName,\n    state: result.address.countrySubdivision,\n    zipcode: result.address.postcode,\n    streetName: result.address.streetName,\n    streetNumber: result.address.streetNumber,\n    countryCode: result.address.countryCode\n  };\n};\n\n/**\n * Batch Geocode\n * @param <string[]>   values    Valueas to geocode\n * @param <function> callback Callback method\n */\nTomTomGeocoder.prototype._batchGeocode = async function (values, callback) {\n  try {\n    const jobLocation = await this.__createJob(values);\n    const rawResults = await this.__pollJobStatusAndFetchResults(jobLocation, values);\n    const parsedResults = this.__parseBatchResults(rawResults);\n    callback(false, parsedResults);\n  } catch (e) {\n    callback(e, null);\n  }\n};\nTomTomGeocoder.prototype.__createJob = async function (addresses) {\n  const body = {\n    batchItems: addresses.map(address => {\n      let query = `/geocode/${encodeURIComponent(address)}.json`;\n      const queryString = new URLSearchParams();\n      if (this.options.country) {\n        queryString.append('countrySet', this.options.country);\n      }\n      if (this.options.limit) {\n        queryString.append('limit', this.options.limit);\n      }\n      if (queryString.toString()) {\n        query += `?${queryString.toString()}`;\n      }\n      return {\n        query\n      };\n    })\n  };\n  const params = {\n    key: this.options.apiKey,\n    waitTimeSeconds: 10\n  };\n  const options = {\n    headers: {\n      'content-type': 'application/json',\n      accept: 'application/json'\n    },\n    redirect: 'manual',\n    body: JSON.stringify(body)\n  };\n  const response = await new Promise((resolve, reject) => {\n    this.httpAdapter.post(this._batchGeocodingEndpoint, params, options, function (err, result) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(result);\n    });\n  });\n  if (response.status !== 303) {\n    const responseContentType = response.headers.get('Content-Type');\n    if (responseContentType && responseContentType.includes('application/json')) {\n      const errorBody = await response.json();\n      throw new Error(errorBody.error.description);\n    } else {\n      throw new Error(await response.text());\n    }\n  }\n  const location = response.headers.get('Location');\n  if (!location) {\n    throw new Error('Location header not found');\n  }\n  return location;\n};\nTomTomGeocoder.prototype.__pollJobStatusAndFetchResults = async function (location, addresses) {\n  let results;\n  let stalledResponsesLeft = 84;\n  for (; !results && stalledResponsesLeft > 0; stalledResponsesLeft -= 1) {\n    let newLocation = location;\n    const status = await new Promise((resolve, reject) => {\n      this.httpAdapter.get(newLocation, {}, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      }, true);\n    });\n    if (status.status === 200) {\n      results = await status.json();\n    } else if (status.status === 202) {\n      newLocation = status.headers.get('Location');\n      if (!newLocation) {\n        throw new Error('Location header not found');\n      }\n    } else if (status.status === 429) {\n      throw new Error('Provider error: Too many requests');\n    } else {\n      throw new Error(`Unexpected status: ${status.status}`);\n    }\n  }\n  if (!results) {\n    throw new Error('Long poll ended without results after 14 minutes');\n  }\n  if (!results.batchItems || results.batchItems.length !== addresses.length) {\n    throw new Error('Batch items length mismatch');\n  }\n  return results;\n};\nTomTomGeocoder.prototype.__parseBatchResults = function (rawResults) {\n  return rawResults.batchItems.map(result => {\n    if (result.statusCode !== 200) {\n      return {\n        error: `statusCode: ${result.statusCode}`,\n        value: []\n      };\n    }\n    return {\n      error: null,\n      value: result.response.results.map(value => ({\n        ...this._formatResult(value),\n        provider: 'tomtom'\n      }))\n    };\n  });\n};\nmodule.exports = TomTomGeocoder;","map":{"version":3,"names":["util","require","AbstractGeocoder","TomTomGeocoder","httpAdapter","options","super_","call","apiKey","Error","inherits","prototype","_endpoint","_batchGeocodingEndpoint","_geocode","value","callback","_this","params","key","language","country","countrySet","limit","url","encodeURIComponent","get","err","result","results","i","length","push","_formatResult","raw","latitude","position","lat","longitude","lon","address","city","localName","state","countrySubdivision","zipcode","postcode","streetName","streetNumber","countryCode","_batchGeocode","values","jobLocation","__createJob","rawResults","__pollJobStatusAndFetchResults","parsedResults","__parseBatchResults","e","addresses","body","batchItems","map","query","queryString","URLSearchParams","append","toString","waitTimeSeconds","headers","accept","redirect","JSON","stringify","response","Promise","resolve","reject","post","status","responseContentType","includes","errorBody","json","error","description","text","location","stalledResponsesLeft","newLocation","res","statusCode","provider","module","exports"],"sources":["/home/pratheek/Desktop/Attendance/frontend/node_modules/node-geocoder/lib/geocoder/tomtomgeocoder.js"],"sourcesContent":["var util = require('util');\nvar AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\nvar TomTomGeocoder = function TomTomGeocoder(httpAdapter, options) {\n  TomTomGeocoder.super_.call(this, httpAdapter, options);\n\n  if (!this.options.apiKey || this.options.apiKey == 'undefined') {\n    throw new Error('You must specify an apiKey');\n  }\n};\n\nutil.inherits(TomTomGeocoder, AbstractGeocoder);\n\n// TomTom geocoding API endpoint\nTomTomGeocoder.prototype._endpoint = 'https://api.tomtom.com/search/2/geocode';\nTomTomGeocoder.prototype._batchGeocodingEndpoint =\n  'https://api.tomtom.com/search/2/batch.json';\n\n/**\n * Geocode\n * @param <string>   value    Value to geocode (Address)\n * @param <function> callback Callback method\n */\nTomTomGeocoder.prototype._geocode = function (value, callback) {\n  var _this = this;\n\n  var params = {\n    key: this.options.apiKey\n  };\n\n  if (this.options.language) {\n    params.language = this.options.language;\n  }\n\n  if (this.options.country) {\n    params.countrySet = this.options.country;\n  }\n\n  if (this.options.limit) {\n    params.limit = this.options.limit;\n  }\n\n  var url = this._endpoint + '/' + encodeURIComponent(value) + '.json';\n\n  this.httpAdapter.get(url, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n\n      for (var i = 0; i < result.results.length; i++) {\n        results.push(_this._formatResult(result.results[i]));\n      }\n\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\nTomTomGeocoder.prototype._formatResult = function (result) {\n  return {\n    latitude: result.position.lat,\n    longitude: result.position.lon,\n    country: result.address.country,\n    city: result.address.localName,\n    state: result.address.countrySubdivision,\n    zipcode: result.address.postcode,\n    streetName: result.address.streetName,\n    streetNumber: result.address.streetNumber,\n    countryCode: result.address.countryCode\n  };\n};\n\n/**\n * Batch Geocode\n * @param <string[]>   values    Valueas to geocode\n * @param <function> callback Callback method\n */\nTomTomGeocoder.prototype._batchGeocode = async function (values, callback) {\n  try {\n    const jobLocation = await this.__createJob(values);\n    const rawResults = await this.__pollJobStatusAndFetchResults(\n      jobLocation,\n      values\n    );\n    const parsedResults = this.__parseBatchResults(rawResults);\n    callback(false, parsedResults);\n  } catch (e) {\n    callback(e, null);\n  }\n};\n\nTomTomGeocoder.prototype.__createJob = async function (addresses) {\n  const body = {\n    batchItems: addresses.map(address => {\n      let query = `/geocode/${encodeURIComponent(address)}.json`;\n      const queryString = new URLSearchParams();\n      if (this.options.country) {\n        queryString.append('countrySet', this.options.country);\n      }\n      if (this.options.limit) {\n        queryString.append('limit', this.options.limit);\n      }\n      if (queryString.toString()) {\n        query += `?${queryString.toString()}`;\n      }\n      return { query };\n    })\n  };\n  const params = {\n    key: this.options.apiKey,\n    waitTimeSeconds: 10\n  };\n  const options = {\n    headers: {\n      'content-type': 'application/json',\n      accept: 'application/json'\n    },\n    redirect: 'manual',\n    body: JSON.stringify(body)\n  };\n  const response = await new Promise((resolve, reject) => {\n    this.httpAdapter.post(\n      this._batchGeocodingEndpoint,\n      params,\n      options,\n      function (err, result) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(result);\n      }\n    );\n  });\n  if (response.status !== 303) {\n    const responseContentType = response.headers.get('Content-Type');\n    if (\n      responseContentType &&\n      responseContentType.includes('application/json')\n    ) {\n      const errorBody = await response.json();\n      throw new Error(errorBody.error.description);\n    } else {\n      throw new Error(await response.text());\n    }\n  }\n  const location = response.headers.get('Location');\n  if (!location) {\n    throw new Error('Location header not found');\n  }\n  return location;\n};\n\nTomTomGeocoder.prototype.__pollJobStatusAndFetchResults = async function (\n  location,\n  addresses\n) {\n  let results;\n  let stalledResponsesLeft = 84;\n  for (; !results && stalledResponsesLeft > 0; stalledResponsesLeft -= 1) {\n    let newLocation = location;\n    const status = await new Promise((resolve, reject) => {\n      this.httpAdapter.get(\n        newLocation,\n        {},\n        function (err, res) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(res);\n        },\n        true\n      );\n    });\n    if (status.status === 200) {\n      results = await status.json();\n    } else if (status.status === 202) {\n      newLocation = status.headers.get('Location');\n      if (!newLocation) {\n        throw new Error('Location header not found');\n      }\n    } else if (status.status === 429) {\n      throw new Error('Provider error: Too many requests');\n    } else {\n      throw new Error(`Unexpected status: ${status.status}`);\n    }\n  }\n  if (!results) {\n    throw new Error('Long poll ended without results after 14 minutes');\n  }\n  if (!results.batchItems || results.batchItems.length !== addresses.length) {\n    throw new Error('Batch items length mismatch');\n  }\n  return results;\n};\n\nTomTomGeocoder.prototype.__parseBatchResults = function (rawResults) {\n  return rawResults.batchItems.map(result => {\n    if (result.statusCode !== 200) {\n      return {\n        error: `statusCode: ${result.statusCode}`,\n        value: []\n      };\n    }\n    return {\n      error: null,\n      value: result.response.results.map((value) => ({\n        ...this._formatResult(value),\n        provider: 'tomtom'\n      }))\n    };\n  });\n};\n\nmodule.exports = TomTomGeocoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}